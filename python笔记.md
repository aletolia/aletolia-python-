# aletolia-pytho
introduction to computation and programing using python
CHAPTER 1 GETTING START
1.计算机可以做些什么？
事实上，计算机只执行了两项工作，一是计算，二是储存计算结果。
此外，我们也可以把知识分成两类
一是陈述性知识（declarative knowledge），它由一些事实性的陈述构成，比如说1+4=5，诸如此类，但我们并不hi因此知道1+4是为什么等于5的。他只是阐述了何为事实
二是命令性的知识，举例来说，下面有一个计算平方根的方法
1. Start with a guess, g.
2. If g*g is close enough to x, stop and say that g is the answer.
3. Otherwise create a new guess by averaging g and x/g, i.e., (g + x/g)/2.
4. Using this new guess, which we again call g, repeat the process until g*g is close
enough to x.
Consider, for example, finding the square root of 25.
1. Set g to some arbitrary value, e.g., 3.
2. We decide that 3*3 = 9 is not close enough to 25.
3. Set g to (3 + 25/3)/2 = 5.67.3
4. We decide that 5.67*5.67 = 32.15 is still not close enough to 25.
5. Set g to (5.67 + 25/5.67)/2 = 5.04
6. We decide that 5.04*5.04 = 25.4 is close enough, so we stop and declare 5.04 to
be an adequate approximation to the square root of 25.
它以一些列的简单的步骤指定了我们在每一步应该做的事，这被称为算法（algorithm）
图灵理论：
丘奇图灵理论直接引出图灵完备性的概念。
如果一种编程语言可以用来模拟通用图灵机，那么它就是图灵完备的。所有现代编程语言都是图灵完备的。因此，任何可以用一种编程语言（如Python）编程的东西都可以用任何其他编程语言（如Java）编程。当然，有些东西可能更容易用一种特定的语言编程，但所有的语言在计算能力方面基本上是平等的。
幸运的是，没有程序员必须用图灵的原始指令构建程序。相反，现代编程语言提供了更大、更方便的原语集。然而，编程作为一系列操作的组装过程的基本思想仍然是核心。
不管一个人有什么样的原语集，也不管他有什么使用它们的方法，编程的优点和缺点都是一样的：计算机会完全按照你的命令去做。这是一件好事，因为这意味着你可以让它做各种有趣和有用的事情。这是一件坏事，因为当它不做你想做的事情时，你通常没有人可以责怪，除了你自己。
世界上有数百种编程语言。没有最好的语言（尽管可以提名一些最差的候选人）。对于不同类型的应用程序，不同的语言是好是坏。例如，MATLAB是处理向量和矩阵的好语言。C语言是编写控制数据网络程序的好语言。PHP是构建网站的好语言。Python是一种很好的通用语言。
每种编程语言都有一组基本结构、语法、静态语义和语义（Each programming language has a set of primitive constructs, a syntax, a static semantics, and a semantics)
静态语义定义了哪些句子是有意义的，而语义定义了那些句子的意义。Python中的基本构造包括文本（例如，数字3.2和字符串'abc'）和中缀运算符（例如，+和/）。
一种语言的语法定义了哪些字符串和符号是格式正确的。例如，在英语中，字符串“Cat dog boy.”在语法上是无效的，因为英语的语法不接受形式为<noun><noun>的句子。在Python中，原语序列3.2+3.2在语法上是良好的，但序列3.2和3.2则不是。
静态语义定义了哪些语法上有效的字符串有意义。
例如，在英语中，字符串“I runs fast”的形式是<degen><verb><副词>，这在句法上是可以接受的。然而，它不是有效的英语，因为名词“I”是单数，动词“runs”是复数。这是一个静态语义错误的例子。在Python中，序列3.2/'abc'在语法上是格式良好的（<literal><operator><literal>），但会产生一个静态语义错误，因为将一个数字除以一个字符串是没有意义的。
一种语言的语义将一个意义与没有静态语义错误的每一个语法正确的符号串相关联。在自然语言中，句子的语义可能是模糊的。例如，一句话“I can't prise that student too highly”，可以是奉承或讽刺。但编程语言的设计使得每个合乎规则的程序都有一个确切的含义。
虽然语法错误是最常见的一种错误（特别是对于那些学习新编程语言的人来说），但它们是最不危险的一种错误。每一种严肃的编程语言都能完成检测语法错误的工作，并且不允许用户执行一个有一个语法错误的程序。此外，在大多数情况下，语言系统对错误的位置给出了足够明确的指示，即显然需要做些什么来纠正错误
静态语义错误的情况要复杂一些。
一些编程语言，例如Java，在允许程序执行之前会进行大量的静态语义检查。其他的，例如C和Python（alas），在程序执行之前，进行的静态语义检查相对较少。Python在运行程序时会进行大量的语义检查。
人们通常不会说程序有语义错误。如果一个程序没有语法错误和静态语义错误，它就有一个意义，即它有语义。当然，一个程序语句有语义不代表它有编程者所想要的语义
  
  CHAPTER 2 INTRODUCTION TO PYTHON
  
  Python是一种通用编程语言，可以有效地用来构建几乎任何不需要直接访问计算机硬件的程序。Python对于具有高可靠性约束（由于其弱静态语义检查）或由许多人或经过长时间构建和维护（同样由于弱静态语义检查）的程序不是最优的。 然而，与许多其他语言相比，Python确实有一些优势。这是一门相对简单的语言，很容易学。因为Python是被设计来解释的，所以它可以提供对新手程序员特别有用的运行时反馈。还有大量免费提供的库与Python接口并提供有用的扩展功能。
  
2.1THE BASIC ELEMENTS OF PYTHON

    Python程序（有时称为脚本）是一系列定义和命令。这些定义由Python解释器在shell中执行。通常，每当程序开始执行时，就会创建一个新的shell。通常一个窗口与shell相关联。
    命令，通常称为语句，指示解释器做某事。
例如，语句print（'Yankees rule！'）指示解释器调用function print，它将输出字符串Yankees rule！在shell关联的窗口

2.1.1 Objects, Expressions, and Numerical Types

    对象（object）是Python程序操作的核心内容。每个对象都有一个类型，它定义了程序可以对该对象执行的各种操作。类型可以是标量类型，也可以是非标量类型。标量对象是不可分割的。把它们看作语言的原子。非标量对象，例如字符串，具有内部结构
    许多类型的对象可以用程序文本中的文字来表示。例如，文本2是一个表示数字的文本，“abc”是一个表示字符串的文本。
Python有四种类型的标量对象：
•int用于表示整数。int类型的文本是以我们通常表示整数的方式编写的（例如，-3、5或10002）。
•float用于表示实数。float类型的文本总是包含一个小数点（例如，3.0或3.17或-28.72）(也可以使用科学记数法编写float类型的文本。例如，literal 1.6E3代表1.6*103，也就是说，它与1600.0相同。）你可能想知道为什么这种类型不称为real。在计算机中，float类型的值作为浮点数存储在计算机中。所有现代编程语言都使用这种表示法，它有许多优点。但是，在某些情况下，它会导致浮点运算的行为方式与实数运算略有不同。我们将在第3.4节中对此进行讨论。
•bool用于表示布尔值True和False。
•none是具有单个值的类型。我们将在第4.1节中对此进行详细说明。
对象和运算符可以组合成表达式，每个表达式的计算结果都是某种类型的对象。我们将其称为表达式的值。
例如，表达式3+2表示int类型的对象5，表达式3.0+2.0表示float类型的对象5.0。
==运算符用于测试两个表达式的计算结果是否相同，以及！=运算符用于测试两个表达式的值是否不同。单个=意味着完全不同的东西，我们将在第2.1.2节中看到。事先警告一下，当你想键入“=”时，你会犯键入“=”的错误。注意这个错误。
符号>>>是一个shell提示符，表示解释器希望用户在shell中键入一些Python代码。当解释器计算在提示符处输入的Python代码时，会生成带有提示符的行下方的行，如以下与解释器的交互所示：
>>> 3 + 2
5
>>> 3.0 + 2.0
5.0
>>> 3 != 2
True
内置的Python函数type可用于查找对象的类型：
>>> type(3)
<type 'int'>
>>> type(3.0)
<type 'float'>
